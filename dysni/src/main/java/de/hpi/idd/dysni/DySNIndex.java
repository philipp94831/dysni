package de.hpi.idd.dysni;

import java.util.Collection;

import de.hpi.idd.dysni.avl.BraidedAVLTree;
import de.hpi.idd.dysni.window.WindowBuilder;

/**
 * A index for the DySNI approach. The elements are inserted into a
 * {@link BraidedAVLTree} to access them sorted by a specific key. Keys are
 * generated by a {@link KeyHandler}. The windows to retrieve possible
 * duplicates are built by the specified {@link WindowBuilder}
 *
 * @param <RECORD>
 *            type of records to be resolved
 * @param <KEY>
 *            type of keys the records are sorted by
 * @param <ID>
 *            type of ids which represent the records
 */
class DySNIndex<RECORD, KEY extends Comparable<KEY>, ID> {

	/** used for computation of the key of an element in the tree */
	private final KeyHandler<RECORD, KEY> keyHandler;
	/** binary search tree with pointers to the in-order neighbors of nodes */
	private final BraidedAVLTree<KEY, ID> tree = new BraidedAVLTree<>();
	/** window builder to retrieve possible duplicates */
	private final WindowBuilder<RECORD, KEY, ID> windowBuilder;

	/**
	 * Construct a new index from the specified configuration.
	 *
	 * @param conf
	 *            the configuration specifying the {@link KeyHandler} and
	 *            {@link WindowBuilder} to be used.
	 */
	public DySNIndex(DySNIndexConfiguration<RECORD, KEY, ID> conf) {
		this.keyHandler = conf.getHandler();
		this.windowBuilder = conf.getBuilder();
	}

	/**
	 * Find possible duplicates by building a window starting from the
	 * corresponding node in the tree.
	 *
	 * @param record
	 *            the record for which duplicates should be found
	 * @return the ids of possible duplicate records
	 */
	public Collection<ID> findCandidates(RECORD record) {
		return windowBuilder.buildWindow(record, tree.find(keyHandler.computeKey(record)));
	}

	/**
	 * Insert a new record into the index using its id
	 *
	 * @param record
	 *            the new record
	 * @param value
	 *            the id it can be identified by
	 */
	public void insert(RECORD record, ID value) {
		tree.insert(keyHandler.computeKey(record), value);
	}
	
	public int size() {
		return tree.nodes();
	}
}
